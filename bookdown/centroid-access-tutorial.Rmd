# Calculate Minimum Distance Access Metric {-#min-distance}

## Research Question {-#CA-research-question}

Spatial Access to specific resource is often considered a multidimensional concept where accessibility can be measured on affordability, availability, accommodation & acceptability [**include reference**]. Distance to the nearest resource is a common metric used to capture the availability of a resource, and in this tutorial we demonstrate how to calculate a minimum distance value from a zip code centroid to a set of resources, such as locations of methadone clinics. Each zip code will be assigned a "minimum distance access metric" as a value that indicates access to resources from that zip code.

## Environment Setup {-#CA-setup}
To replicate the codes & functions illustrated in this tutorial, youâ€™ll need to have R and RStudio downloaded and installed on your system. This tutorial assumes some familiarity with the R programming language.

#### Packages used {-#CA-packages1}
We will use the following packages in this tutorial:

- `sf`: to manipulate spatial data
- `tmap`: to visualize and create maps
- `units`: to convert units within spatial data

#### Required Inputs and Expected Outputs {-#CA-i-o}
Our inputs will be:

- a CSV file with the locations of our resources ("chicago_methadone.csv"), and 
- a zip code boundary file ("chicago_zips.shp"). 

We will calculate the minimum distance between the resources and the centroids of the zip codes, then save the results as a shapefile and as a CSV. Our final result will be a shapefile/CSV with the minimum distance value for each zip. 

#### Install and load the packages {-#CA-packages2}
First, let's install the relevant R packages:

```{r install, eval=FALSE}
install.packages("sf")
install.packages("tmap")
install.packages("units")
```


Then load the libraries for use. (The message you see about GEOS, GDAL, and PROJ refer to the software libraries that allow you to work with spatial data.)

```{r load}
library(sf)
library(tmap)
library(units)
```

## Read in resource data {-#CA-read-resources}

We will use a CSV of methadone clinic addresses in Chicago as an example. This file represents point locations of clinics.

```{r read}
methadone_clinics <- read.csv("data/chicago_methadone.csv")
```

Let's take a look at the first few rows of the dataset.

```{r glimpse}
head(methadone_clinics)
```

Our data has been geocoded, which means that it has latitude and longitude as columns associated with the address in the data. If you do not have this information, check the [Geocoding and Visualizing Point Data](#geocode-points) to geocode your data.

Next we convert the dataframe of addresses to a spatial data frame using the `st_as_sf()` function. The `coords` argument specifies which two columns are the X and Y for your data. We set the `crs` argument equal to 4326 because this data is in latitude and longitude (otherwise known as "unprojected", which means it is not in feet or meters).

```{r convert}
meth_sf <- st_as_sf(methadone_clinics, 
                    coords = c("Longitude", "Latitude"),
                    crs = 4326)

meth_sf
```

Note that this is a data frame, but that it has a final column called "geometry" that stores the spatial information.

We can now plot the location of the methadone clinics with base R. We use the `st_geometry()` function to just get a single point map from the geographies.

```{r}
plot(st_geometry(meth_sf))
```

To make a slightly more interesting map, you can add an interactive basemap with tmap, using the `tmap_mode` function to change to "view" mode:

```{r}
tmap_mode("view")

tm_shape(meth_sf) +
  tm_dots()
```


## Read in zip code data {-#CA-read-zips}

If you have zip code boundary data from the Census (or other relevant site), you can load them into R with the `read_sf` command. Boundary data is commonly stored in the **shapefile** format, which has both a spatial (.shp, .shx, .prj) and a flat-file (.dbf) component. Shapefiles are made of four files (.shp, .shx, .prj, .dbf), all which needed to be in the same folder for the file to be read.

```{r read zips}
chicago_zips <- read_sf("data/chicago_zips.shp")
```


**Note:** If you do not have the zip boundary data, please see the [Get Geometry](#CD-get-geometry) from [Downloading Community Contextual Data] (#contextual-data) for instructions on how to pull them directly from the Census website into R.

If we take a look at the top of the data, we can see that the zip codes have data attached to them. The last column is the "geometry" column, which stores the spatial data. 

Additionally, there is a header with some spatial metadata about the data frame, including the type of geometry ("MULTIPOLYGON"), the bounding box (the square that surrounds your data), and the geographic projection (4326 is the shortcode reference for the string that starts "+proj=longlat +datum=WGS84 +no_defs"). Otherwise, this is just like your normal R tabular data frame.

```{r}
head(chicago_zips)
```

We can check that we pulled the zip code data properly by plotting it. Again, we use the `st_geometry()` function to just get the outline of the geometries.

```{r plot-zips}
plot(st_geometry(chicago_zips))
```

We can add a second layer in blue with the access locations:

```{r plot-zips-resources}
plot(st_geometry(chicago_zips))
plot(st_geometry(meth_sf), col = "blue", add = TRUE)
```

With multiple layers, it can be easier to use tmap to plot:

```{r}
tmap_mode("plot")

tm_shape(chicago_zips) +
  tm_borders() +
tm_shape(meth_sf) +
  tm_dots(col = "blue", size = 0.2)
```

Again, we can create an interactive map with tmap:

```{r plot-interactive-zips-resources}
tmap_mode("view")
tm_shape(chicago_zips) +
  tm_borders() +
tm_shape(meth_sf) +
  tm_dots()
```


## Calculate centroids of zip code boundaries {-#CA-calculate-centroids}

Now, we will calculate the centroids of the zip code boundaries. We will first need to project our data, which means change it from latitude and longitude to meaningful units, like ft or meters, so we can calculate distance properly. We'll use the Illinois State Plane projection, with an EPSG code of 3435.

**Aside**: To find the most appropriate projection for your data, do a Google Search for which projection works well - for state level data, each state has a State Plane projection with a specific code, known as the EPSG. I use epsg.io to check projections - here's the [New York State Plane](https://epsg.io/2263) page.

Use the `st_transform` function to change the projection of the data. Notice how the values in `geometry` go from being relatively small (unprojected, lat/long) to very large (projected, in US feet).

```{r project-zips}
chicago_zips <- st_transform(chicago_zips, 3435)

chicago_zips
```

Then, we will calculate the centroids:

```{r calc-centroids}
chicago_centroids <- st_centroid(chicago_zips)

chicago_centroids
```

For each zip code, this will calculate the centroid, and the output will be a point dataset.

Plot to double check that everything is ok. The `st_geometry()` function will once again just return the outline:

```{r plot-zips-centroids}
plot(st_geometry(chicago_zips))
plot(st_geometry(chicago_centroids), add = TRUE, col = "red")
```

Once again, we can create an interactive map:

```{r plot-interactive-zips-centroids}
tm_shape(chicago_zips) +
  tm_borders() +
tm_shape(chicago_centroids) +
  tm_dots()
```


## Ensure that centroid and resource projections match {-#CA-correct-projection}

If we immediately try to calculate the distance between the zip centroids and the locations of the resources using the `st_distance` function, we'll get an error:

```{r eval=FALSE}
st_distance(chicago_centroids, meth_sf, by_element = TRUE)
```

```
Error in st_distance(chicago_centroids, meth_sf, by_element = TRUE) : st_crs(x) == st_crs(y) is not TRUE
```
Why is there an error? Because the projection of the centroids and the resource locations don't match up. Let's project the resource locations so that they match the projection of the centroids.

First, use the `st_crs` function to check that the coordinate reference system (or projection) is the same. They're not, so we have to fix it.

```{r check-crs-1}
st_crs(chicago_centroids)
st_crs(meth_sf)
```

We'll take the CRS from the zip code centroids data, and use it as input to `st_transform` applied to the methadone clinics data.

```{r project resources}
new_crs <- st_crs(chicago_centroids)
new_crs

meth_sf <- st_transform(meth_sf, new_crs)
```

If we check the CRS again, we now see that they match. **Mismatched projections are a commonly made mistake in geospatial data processing.**

```{r check-crs-2}
st_crs(chicago_centroids)
st_crs(meth_sf)
```

Now we have the zip boundaries, the centroids of the zips, and the resource locations, as shown below. Next, we will calculate the distance to the nearest resource from each zip code centroid.

```{r plot-zips-centroids-resources}
plot(st_geometry(chicago_zips))
plot(st_geometry(chicago_centroids), col = "red", add = TRUE)
plot(st_geometry(meth_sf), col = "blue", add = TRUE)
```

## Calculate distance from centroid to nearest resource {-#CA-distance}

First, we'll identify the resource that is the closest to a zip centroid using the `st_nearest_feature` function. (It will return the index of the object that is nearest, so we will subset the resources by the index to get the nearest object.)

```{r find nearest resource}
nearest_clinic_indexes <- st_nearest_feature(chicago_centroids, meth_sf)

nearest_clinic <- meth_sf[nearest_clinic_indexes,]

nearest_clinic
```

Then, we will calculate the distance between the nearest resource and the zip code centroid with the `st_distance` function. As shown above, make sure both of your datasets are projected, and in the same projection, before you run `st_distance`.

```{r calc min dists}
min_dists <- st_distance(chicago_centroids, nearest_clinic, by_element = TRUE)

min_dists
```

This is in US feet. To change to a more meaningful unit, such as miles, we can use the `set_units()` function:

```{r convert units}
min_dists_mi <- set_units(min_dists, "mi")

min_dists_mi
```

We then rejoin the minimum distances to the zip code data, by column binding `min_dists_mi` to the original `chicago_zips` data.

```{r rejoin}
min_dist_sf <- cbind(chicago_zips, min_dists_mi)
min_dist_sf
```

We can now visualize the zip-level access to methadone clinics using our new access metric, using the `tmap` package.

```{r}
tmap_mode("plot")

tm_shape(min_dist_sf) +
  tm_polygons("min_dists_mi", 
              title = "Minimum Distance (mi)") +
  tm_layout(main.title = "Minimum Distance from Zip Centroid\n to Methadone Clinic",
            main.title.position = "center",
            main.title.size = 1)
```

Access by zip code can also be combined with locations of resources:

```{r}
tm_shape(min_dist_sf) +
  tm_polygons("min_dists_mi", 
              title = "Minimum Distance (mi)") +
  tm_shape(meth_sf) +
  tm_dots(size = 0.2) +
  tm_layout(main.title = "Minimum Distance from Zip Centroid\n to Methadone Clinic",
            main.title.position = "center",
            main.title.size = 1)
```


## Save as zip-code level dataset {-#CA-save}

To save our final result to a CSV, use the `layer_options = "GEOMETRY=AS_XY"` command. Note that this option only works when you are working with point data.

```{r, eval=FALSE, write-csv}
write_sf(min_dist_sf, "min_dist.csv", layer_options = "GEOMETRY=AS_XY")
```

We can also write out this data to a shapefile format:

```{r, eval=FALSE, write-shp}
write_sf(min_dist_sf, "min_dists_sf.shp")
```


## Contributors and Further Resources {-#CA-contributors}
#### Contributors {-}
Angela Li, University of Chicago is the principal author of the initial version of this tutorial. Helpful improvements provided by Moksha Menghaney and Marynia Kolak. 

Email: mmenghaney@uchicago.edu for any issues/comments.