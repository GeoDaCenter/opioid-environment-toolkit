[
["index.html", "Opioid Environment Toolkit Introduction Software Basics Author Team", " Opioid Environment Toolkit Created by : Center for Spatial Data Science `Last Updated : 2020-10-07 Introduction This toolkit provides an introduction to GIS and spatial analysis for opioid environment applications that will allow practitioners to support their communities with better data analytics and visualization services. We introduce basic spatial analytic functionalities using open source tools, mainly in R, using applied examples for visualizing, mapping, and understanding the opioid risk environment. This toolkit was developed for the JCOIN network by the team at the Center for Spatial Data Science at the University of Chicago. Software Basics We assume a basic knowledge of R and coding languages for these toolkits. However, beginners can check out these resources for access to the basics. For most of the tutorials in this toolkit, you’ll need to have R and RStudio downloaded and installed on your system. You should be able to install packages, and have very basic familiarity with R following intro-level tutorials provided through installation guides. You can also refer to this R for Social Scientists tutorial developed by Data Carpentry for a refresher. You should also know how to find the address to a folder on your computer system. We will work with following libraries, so please be sure to install: sf tmap tidyverse tidycensus Note: You may find another library called sp if you google search spatial analysis in R. Note that sp and sf are two different packages. If you need to work between these two R spatial ecosystems, see this guide for a translation of sp to sf commands. Author Team The tutorials in this toolkit were co-authored by Marynia Kolak, Moksha Menghaney, Qinyun Lin, and Angela Li at the Center for Spatial Data Science at the University of Chicago. Our group is a part of the Policy and Practice Observational and Survey Research Core of the (JCOIN network)[https://heal.nih.gov/research/research-to-practice/jcoin], within the Methodology and Adsvanced Analytic Resource Center (MAARC). "],
["spatial-data-introduction.html", "1 Spatial Data Introduction 1.1 Defining spatial data 1.2 Spatial data formats 1.3 Spatial data types 1.4 Coordiante Reference System Further resources", " 1 Spatial Data Introduction 1.1 Defining spatial data Spatial data refers to data that contain information about specific locations, and the information content of the data may change with location. In other words, “information” and “location” are two important elements in spatial data. In some occassions, spatial data may only include “location.” But without “location,” the data is no longer spatial anymore. For example, a spatial data that describes the resource distribution of Medications for Opioid Overuse Disorder (MOUDs) must contain location information of these MOUD resources, otherwise the data becomes a non-spatial list of those resources. For the purpose of this tutorial, we will only briefly introduce some important concepts in spatial data. See Further Resources if you would like to learn more about these concepts. 1.2 Spatial data formats Spatial data can be stored in a text file such as comma-sperated values (CSV) files. However, the text file needs to have essential location columns with latitude and longitude to represent the coordinate location of a spatial object. Importantly, a CSV file with lat/long columns is only a flat/non-spatial file, unless the spatial location context is enabled. R’s spatial ecosystem has been rapidly evolving. The package sf is well known for unifying interface to other important spatial data analysis packages, including sp, rgdal, and rgeos, so that one would not need to switch “context” in mind when calling functions from different packages. In R ecosystem, data frame is used to store data tables. A data frame represents data in a format of table where the columns are vectors with the same length and each vector/column contains a single type of data. When we use data frames for statistical anlayses, each column/vector usually represents one variable, such as age (numeric vector) or name (character vector). In sf, simple feature objects in spatial data are also stored in a data frame, with one vector/column containing geographic data, which is usually named as “geometry” or “geom”. The most common spatial data format is the shapefile, which comes from ESRI/ArcGIS proprietary software. The shapefile file format (.shp for short) includes a minimum of 4 files, with a common prefix and different filename extensions .shp, .shx, .dbf, and .prj. In order to work with the spatial data, we need all these four components of the shapefile stored in the same directory, so that the software (such as R) can know how to project spatial objects onto a geographic or coordinate space (i.e., spatial location context is enabled). There are other spatial data formats as well such as geojson and KML. We focus on sf (within R) and shapefile (as file format) here. 1.3 Spatial data types Two common formats of spatial data are vector and raster data. For the purpose of this tutorial, we will focus on vector data that represents the world surface using points, lines, and polygons. Connecting points can generate lines, and connecting lines that crate an enclosed area can generate polygons. The figure below shows 7 commonly used geometry types based on points, lines, and polygons. The figure is from this Chapter 2 Geographic data in R. This book Geocomputation with R is also an incredible source for those who are interested in learning more details regarding geographic data analysis, visualization, and modeling. 1.4 Coordiante Reference System As noted before, the most fundamental element of a spatial data is “location.” Coordinate reference system (CRS) tells your mapping software (such as R) what method should be used to flatten or project the Earth’s surface onto a 2-dimensional map. Importantly, different CRS implies different ways of projections and generates substantially different visualizations. For example, following are two world maps using different projections. (Check out here for more different world map projections!) Because different CRS implies different ways of projections and generates substantially different visualizations, it is important to make sure the CRS accompanied with each spatial data are the same before implementing any spatial joining practices. In sf, you can use the function st_crs to check the CRS used in one data, and the function st_transform to project the data to a particular CRS. See this Interactive Tutorial that demonstrates these functions. The CRS concept can be tricky to comprehend and utilize in practice, so we will come back to this several times in our tutorials. Further resources See Chapter 2 Geographic data in R in Geocomputation with R for more info about Vector data, Raster data, and Coordiante Reference Systems. See this Software Carpentry workshop for more explanations to better understand coordinate reference systems. See this Interactive Tutorial that uses sf package to project spatial data in R. "],
["buffer_analysis.html", "2 Buffer Analysis 2.1 Overview 2.2 Environment Setup 2.3 Simple Overlay Map 2.4 Spatial Transformation 2.5 Generate Buffers 2.6 Rinse &amp; Repeat", " 2 Buffer Analysis 2.1 Overview Once we have spatially referenced resource locations, it’s helpful to plot the data in the community of interest for some preliminary analysis. In this tutorial we will plot Methadone Providers in Chicago and community areas to provide some context. We will also generate a simple 1-mile buffer service area around each provider to highlight neighborhoods with better, and worse, access to resources. In order to accomplish this task, we will need to standardize our spatial data (clinic points, and community areas) with an appropriate coordinate reference system. Finally, we’ll make some maps! Our objectives are thus to: Overlay clinical providers (points) and community areas (polygons) Use a spatial transform operation to change coordinate reference systems Conduct a simple buffer analysis 2.2 Environment Setup To replicate the code &amp; functions illustrated in this tutorial, you’ll need to have R and RStudio downloaded and installed on your system. This tutorial assumes some familiarity with the R programming language. 2.2.1 Input/Output Our inputs will be two shapefiles, and a geojson (all spatial file formats). These files can be found here, though the providers point file was generated in the Geocoding tutorial. Note that all four files are required (.dbf, .prj, .shp, and .shx) to consitute a shapefile. Chicago Methadone Clinics, methadoneClinics.shp Chicago Zip Codes, chicago_zips.shp Chicago City Boundary, BoundariesChicago.geojson We will generate a 1-mile buffer around each point, and generate maps with the zip code areas for context. We will also export the final buffer areas as another shapefile for future use. Finally, we’ll generate a more beautiful map by including the city boundary. If you don’t have a shapefile of your data, but already have geographic coordinates as two columns in your CSV file, you can still use this tutorial. A reminder of how to transform your CSV with coordinates into a spatial data frame in R can be found here. 2.2.2 Load Libraries We will use the following packages in this tutorial: sf: to manipulate spatial data tmap: to visualize and create maps First, load the required libraries. library(sf) library(tmap) 2.2.3 Load Data Load in the MOUD resources shapefile. MetClinics &lt;- st_read(&quot;data/methadoneClinics.shp&quot;) ## Reading layer `methadoneClinics&#39; from data source `/Users/qinyun/Documents/opioid-environment-toolkit/data/methadoneClinics.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 27 features and 8 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: -87.7349 ymin: 41.68698 xmax: -87.57673 ymax: 41.96475 ## geographic CRS: WGS 84 Next, we load a shapefile of Chicago zip codes. You can often find shapefiles (or spatial data formats like geojson) on city data portals for direct download. We will walk you through downloading zip code boundaries directly through the Census via R in a later tutorial. Areas &lt;- st_read(&quot;data/chicago_zips.shp&quot;) ## Reading layer `chicago_zips&#39; from data source `/Users/qinyun/Documents/opioid-environment-toolkit/data/chicago_zips.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 85 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -88.06058 ymin: 41.58152 xmax: -87.52366 ymax: 42.06504 ## geographic CRS: WGS 84 CityBoundary &lt;- st_read(&quot;data/BoundariesChicago.geojson&quot;) ## Reading layer `BoundariesChicago&#39; from data source `/Users/qinyun/Documents/opioid-environment-toolkit/data/BoundariesChicago.geojson&#39; using driver `GeoJSON&#39; ## Simple feature collection with 1 feature and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -87.94011 ymin: 41.64454 xmax: -87.52414 ymax: 42.02304 ## geographic CRS: WGS 84 Quickly view the first few rows of the zip codes and clinics using your favorite function (head, glimpse, str, and so forth). head(Areas) ## Simple feature collection with 6 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -88.06058 ymin: 41.73452 xmax: -87.58209 ymax: 42.04052 ## geographic CRS: WGS 84 ## ZCTA5CE10 GEOID10 CLASSFP10 MTFCC10 FUNCSTAT10 ALAND10 AWATER10 INTPTLAT10 INTPTLON10 geometry ## 1 60501 60501 B5 G6350 S 12532295 974360 +41.7802209 -087.8232440 MULTIPOLYGON (((-87.86289 4... ## 2 60007 60007 B5 G6350 S 36493383 917560 +42.0086000 -087.9973398 MULTIPOLYGON (((-88.06058 4... ## 3 60651 60651 B5 G6350 S 9052862 0 +41.9020934 -087.7408565 MULTIPOLYGON (((-87.77559 4... ## 4 60652 60652 B5 G6350 S 12987857 0 +41.7479319 -087.7147951 MULTIPOLYGON (((-87.74205 4... ## 5 60653 60653 B5 G6350 S 6041418 1696670 +41.8199645 -087.6059654 MULTIPOLYGON (((-87.62623 4... ## 6 60654 60654 B5 G6350 S 1464813 113471 +41.8918225 -087.6383036 MULTIPOLYGON (((-87.64775 4... 2.3 Simple Overlay Map We can plot these quickly using the tmap library to ensure they are overlaying correctly. If they are, our coordinate systems are working correctly. When using tmap the first parameter references the spatial file we’d like to map (tm_shape), and the next parameter(s) indicate how we want to style the data. For polygons, we can style tm_borders to have a slightly transparent boundary. For the point data, we will use red dots that are sized appropriately using the tm_dots parameter. When working with tmap or any other library for the first time, it’s helpful to review the documentation and related tutorials for more tips on usability. We use the tmap “plot” view mode to view the data in a static format. tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting ## 1st layer (gets plotted first) tm_shape(Areas) + tm_borders(alpha = 0.4) + ## 2nd layer (overlay) tm_shape(MetClinics) + tm_dots(size = 0.4, col=&quot;red&quot;) 2.4 Spatial Transformation Next, we check the Coordinate Reference System for our data. Are the coordinate systems for clinic points and community areas the same? For R to treat both coordinate reference systems the same, the metadata has to be exact. st_crs(MetClinics) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] st_crs(Areas) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] We can see that while both have a code of 4326 and appear to both be WGS84 systems, they are not encoded in exactly the same why. Thus, R will treat them differently – which will pose problems for spatial analysis that interacts these two layers. One way of resolving this challenge is to transform the spatial reference system so that they are exact. To complicate matters, we are also interested in generating a buffer to approximate a “service area” around each methadone provider. If we want to use a buffer of a mile, we will need to use a spatial data reference system that uses an appropriate distance metric, like feet or meters. As noted in the previous tutorial the WGS84 coordinate reference system uses degrees, and is not an appropriate CRS for the spatial analysis we require. Thus, our next goal is to transform both spatial data files into a new, standardized CRS. 2.4.1 Transform CRS To calculate buffers, we will need to convert to a different CRS that preserves distance. Trying using a search engine like Google with search terms “CRS Illinois ft”, for example, to look for a code that provides what we need. After searching, we found EPSG:3435 uses feet for a distance metric. We’ll use that! First, set a new CRS. CRS.new &lt;- st_crs(&quot;EPSG:3435&quot;) Next, transform both datasets to your new CRS. MetClinics.3435 &lt;- st_transform(MetClinics, CRS.new) Areas.3435 &lt;- st_transform(Areas, CRS.new) Check the CRS of both datasets again. If they are identical you’re ready to move onto the next step! 2.5 Generate Buffers Now we are ready to generate buffers! We will create a 1-mile buffer to approximate a service area for an urban area. When choosing an appropriate buffer, consider the conceptual model driving your decision. It’s recommended to review literature on common thresholds, consult patients on how they commonly access services, and consider varying travel modes. We choose a mile as a walkable distance for urban environments, commonly used for acceptable distance to travel for grocery stores in cities. Because methadone providers may be utilized as often as grocery stores for some patients, it may be a reasonable start for analysis. We use the st_buffer function to create a buffer, and use 5280 feet to equal one mile. MetClinic_buffers &lt;- st_buffer(MetClinics.3435, 5280) Inspect the structure of the object you just created. Note that this is a new data object, represented as multiple polygons (rather than multiple points). Each buffer around each point is a separate entity. 2.5.1 Visualize buffers Always visualize a spatial object when calculating one, to confirm it worked correctly. If your buffers are much larger or smaller than expected, it’s often a case of mistaken CRS or projection. Retransform your data, and try again. We use tmap again, in the static plot mode. We layer our zip code areas, then providers, and then finally the buffers. We use red to color clinics, and blue to color buffers. tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting tm_shape(Areas.3435) + tm_borders() + tm_shape(MetClinics.3435) + tm_dots(col = &quot;red&quot;) + tm_shape(MetClinic_buffers) + tm_borders(col = &quot;blue&quot;) While this map shows our buffers were calculated correctly, the default settings make it difficult to view. To improve aesthetics we change the transparency of zip code boundaries by adjusting the alpha level. We add a fill to the buffers, and make it transparent. We increase the size of the points. # Map Housing Buffers tm_shape(Areas) + tm_borders(alpha = 0.6) + tm_shape(MetClinic_buffers) + tm_fill(col = &quot;blue&quot;, alpha = .4) + tm_borders(col = &quot;blue&quot;) + tm_shape(MetClinics.3435) + tm_dots(col = &quot;red&quot;, size = 0.2) 2.5.2 Buffer union While individual buffers are interesting and can be useful to consider overlapping service areas, we are also interested in getting a sense of which areas fall within a 1-mile service area in our study region – or not. For this, we need to to use a union spatial operation. This will flatten all the individual buffers into one entity. union.buffers &lt;- st_union(MetClinic_buffers) Inspect the data structures of MetClinic_buffers and union.buffers to see what happens to the data in this step. Finally, we map the buffer union. tm_shape(Areas) + tm_borders()+ tm_shape(union.buffers) + tm_fill(col = &quot;blue&quot;, alpha = .2) + tm_borders(col = &quot;blue&quot;) + tm_shape(MetClinics.3435) + tm_dots(col = &quot;red&quot;, size = 0.4) 2.5.3 Save Data We will save the merged 1-mile buffers to bring into maps for future analysis. The st_write function does the trick. Uncomment, and run on your system! #st_write(union.buffers, &quot;data/methadoneClinics_1mi.shp&quot;) 2.6 Rinse &amp; Repeat From here, we can generate additional buffers to compare access associations and generate multiple visuals. We generate a two-mile buffer to add: MetClinic_2mbuffers &lt;- st_buffer(MetClinics.3435, 10560) And then leverage tmap parameter specifications to further customize the a map showing multiple buffers. Here, we add the City of Chicago boundary and soften the zip code boundaries. We add a bounding box for the first zip code layer, so that the whole map is centered around the city boundary (even those the zip codes are layered first). We adjust the transparency of the buffer fills, use different colors, and adjust borders to make the visuals pop. We use the tmap_layout function to take away the frame, add and position a title. Explore the tmap documentation further to find additional options for legends and more. To find color options in R, there are multiple guides online (like this one). tm_shape(Areas, bbox=CityBoundary) + tm_borders(alpha = 0.2) + tm_shape(CityBoundary) + tm_borders() + tm_shape(MetClinic_2mbuffers) + tm_fill(col = &quot;lightblue1&quot;, alpha = .4) + tm_borders(col = &quot;dimgray&quot;, alpha = .4) + tm_shape(MetClinic_buffers) + tm_fill(col = &quot;blue&quot;, alpha = .4) + tm_borders(col = &quot;blue&quot;) + tm_shape(MetClinics.3435) + tm_dots(col = &quot;darkslategray&quot;, size = 0.2) + tm_layout(main.title = &quot;Methadone Clinic Service Areas in Chicago&quot;, main.title.position = &quot;center&quot;, main.title.size = 1, frame = FALSE) Next, we’ll try an interactive map to better explore the data that we have. We switch the tmap_mode to “view” and focus on our merged 1-mile buffer service areas. We add labels for zip codes using the tm_text parameter, and adjust the size. The resulting map lets us zoom and out to explore the data. Clicking on a point will give additional details about the Methadone provider. tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(Areas) + tm_borders(alpha = 0.5, col=&quot;gray&quot;)+ tm_text(&quot;GEOID10&quot;, size = 0.7) + tm_shape(CityBoundary) + tm_borders() + tm_shape(union.buffers) + tm_fill(col = &quot;blue&quot;, alpha = .2) + tm_borders(col = &quot;blue&quot;) + tm_shape(MetClinics.3435) + tm_dots(col = &quot;red&quot;) "],
["link-contextual-data.html", "3 Link Community Data 3.1 Overview 3.2 Environment Setup 3.3 Load data 3.4 Clean &amp; Merge Data 3.5 Visualize Data", " 3 Link Community Data 3.1 Overview Stuff items 3.2 Environment Setup To replicate the codes &amp; functions illustrated in this tutorial, you’ll need to have R and RStudio downloaded and installed on your system. This tutorial assumes some familiarity with the R programming language. 3.2.1 Packages used We will use the following packages in this tutorial: sf: to manipulate spatial data tmap: to visualize and create maps units: to convert units within spatial data 3.2.2 Required Inputs and Expected Outputs Our inputs will be: a SHP zip code boundary file (“chicago_zips.shp”), a a CSV file with COVID case data from the city data portal, and a SHP file with the locations of our resources (“methadoneClinics.shp”), We will calculate the minimum distance between the resources and the centroids of the zip codes, then save the results as a shapefile and as a CSV. Our final result will be a shapefile/CSV with the minimum distance value for each zip. 3.2.3 Load the packages Load the libraries for use. library(sf) library(tmap) 3.3 Load data First we’ll load the update zip code dataset from a previous labs. chicago_zips &lt;- read_sf(&quot;data/chicago_zips.shp&quot;) str(chicago_zips) ## tibble [85 × 10] (S3: sf/tbl_df/tbl/data.frame) ## $ ZCTA5CE10 : chr [1:85] &quot;60501&quot; &quot;60007&quot; &quot;60651&quot; &quot;60652&quot; ... ## $ GEOID10 : chr [1:85] &quot;60501&quot; &quot;60007&quot; &quot;60651&quot; &quot;60652&quot; ... ## $ CLASSFP10 : chr [1:85] &quot;B5&quot; &quot;B5&quot; &quot;B5&quot; &quot;B5&quot; ... ## $ MTFCC10 : chr [1:85] &quot;G6350&quot; &quot;G6350&quot; &quot;G6350&quot; &quot;G6350&quot; ... ## $ FUNCSTAT10: chr [1:85] &quot;S&quot; &quot;S&quot; &quot;S&quot; &quot;S&quot; ... ## $ ALAND10 : chr [1:85] &quot;12532295&quot; &quot;36493383&quot; &quot;9052862&quot; &quot;12987857&quot; ... ## $ AWATER10 : chr [1:85] &quot;974360&quot; &quot;917560&quot; &quot;0&quot; &quot;0&quot; ... ## $ INTPTLAT10: chr [1:85] &quot;+41.7802209&quot; &quot;+42.0086000&quot; &quot;+41.9020934&quot; &quot;+41.7479319&quot; ... ## $ INTPTLON10: chr [1:85] &quot;-087.8232440&quot; &quot;-087.9973398&quot; &quot;-087.7408565&quot; &quot;-087.7147951&quot; ... ## $ geometry :sfc_MULTIPOLYGON of length 85; first list element: List of 1 ## ..$ :List of 1 ## .. ..$ : num [1:671, 1:2] -87.9 -87.9 -87.9 -87.9 -87.9 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:9] &quot;ZCTA5CE10&quot; &quot;GEOID10&quot; &quot;CLASSFP10&quot; &quot;MTFCC10&quot; ... meth_sf &lt;- st_read(&quot;methadoneClinics.shp&quot;) ## Reading layer `methadoneClinics&#39; from data source `/Users/qinyun/Documents/opioid-environment-toolkit/methadoneClinics.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 27 features and 8 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: -87.7349 ymin: 41.68698 xmax: -87.57673 ymax: 41.96475 ## geographic CRS: WGS 84 Next, we’ll load some new data we’re interested in joining in: Chicago COVID-19 Cases, Tests, and Deaths by ZIP Code, found on the city data portal here. We’ll load in a CSV and inspect the data: COVID &lt;- read.csv(&quot;data/COVID-19_Cases__Tests__and_Deaths_by_ZIP_Code.csv&quot;) str(COVID) ## &#39;data.frame&#39;: 1860 obs. of 21 variables: ## $ ZIP.Code : chr &quot;60603&quot; &quot;60604&quot; &quot;60611&quot; &quot;60611&quot; ... ## $ Week.Number : int 39 39 16 15 11 10 11 12 13 14 ... ## $ Week.Start : chr &quot;09/20/2020&quot; &quot;09/20/2020&quot; &quot;04/12/2020&quot; &quot;04/05/2020&quot; ... ## $ Week.End : chr &quot;09/26/2020&quot; &quot;09/26/2020&quot; &quot;04/18/2020&quot; &quot;04/11/2020&quot; ... ## $ Cases...Weekly : int 0 0 8 7 NA NA NA NA NA NA ... ## $ Cases...Cumulative : int 13 31 72 64 NA NA NA NA NA NA ... ## $ Case.Rate...Weekly : int 0 0 25 22 NA NA NA NA NA NA ... ## $ Case.Rate...Cumulative : num 1107 3964 222 197 NA ... ## $ Tests...Weekly : int 25 12 101 59 6 0 0 1 3 4 ... ## $ Tests...Cumulative : int 327 339 450 349 9 0 0 1 4 8 ... ## $ Test.Rate...Weekly : int 2130 1534 312 182 14 0 0 85 256 341 ... ## $ Test.Rate...Cumulative : num 27853.5 43350.4 1387.8 1076.3 21.7 ... ## $ Percent.Tested.Positive...Weekly : num 0 0 0.1 0.1 NA NA NA NA NA NA ... ## $ Percent.Tested.Positive...Cumulative: num 0 0.1 0.2 0.2 NA NA NA NA NA NA ... ## $ Deaths...Weekly : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Deaths...Cumulative : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Death.Rate...Weekly : num 0 0 0 0 0 0 0 0 0 0 ... ## $ Death.Rate...Cumulative : num 0 0 0 0 0 0 0 0 0 0 ... ## $ Population : int 1174 782 32426 32426 41563 1174 1174 1174 1174 1174 ... ## $ Row.ID : chr &quot;60603-39&quot; &quot;60604-39&quot; &quot;60611-16&quot; &quot;60611-15&quot; ... ## $ ZIP.Code.Location : chr &quot;POINT (-87.625473 41.880112)&quot; &quot;POINT (-87.629029 41.878153)&quot; &quot;POINT (-87.620291 41.894734)&quot; &quot;POINT (-87.620291 41.894734)&quot; ... 3.4 Clean &amp; Merge Data #COVID1 &lt;- COVID[, c(&quot;`ZIP Code`&quot;, &quot;`Percent Tested Positive - Cumulative`&quot;,&quot;Population&quot;)] #head(COVID1) head(chicago_zips) ## Simple feature collection with 6 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -88.06058 ymin: 41.73452 xmax: -87.58209 ymax: 42.04052 ## geographic CRS: WGS 84 ## # A tibble: 6 x 10 ## ZCTA5CE10 GEOID10 CLASSFP10 MTFCC10 FUNCSTAT10 ALAND10 AWATER10 INTPTLAT10 INTPTLON10 geometry ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [°]&gt; ## 1 60501 60501 B5 G6350 S 12532295 974360 +41.78022… -087.8232… (((-87.86289 41.7544, -87.86247 41.75… ## 2 60007 60007 B5 G6350 S 36493383 917560 +42.00860… -087.9973… (((-88.06058 41.9997, -88.06057 42.00… ## 3 60651 60651 B5 G6350 S 9052862 0 +41.90209… -087.7408… (((-87.77559 41.90875, -87.77498 41.9… ## 4 60652 60652 B5 G6350 S 12987857 0 +41.74793… -087.7147… (((-87.74205 41.77113, -87.74182 41.7… ## 5 60653 60653 B5 G6350 S 6041418 1696670 +41.81996… -087.6059… (((-87.62623 41.81469, -87.6259 41.81… ## 6 60654 60654 B5 G6350 S 1464813 113471 +41.89182… -087.6383… (((-87.64775 41.8964, -87.64764 41.89… COVID$GEOID10&lt;- as.character(COVID$ZIP.Code) Let’s merge the data using the zip code geographic identifier, “ZIP Code” field, to bring in the the Percent Tested Positive - Cumalative dataset. new &lt;- merge(chicago_zips, COVID, by = &quot;GEOID10&quot;) head(new) ## Simple feature collection with 6 features and 30 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -87.63396 ymin: 41.88083 xmax: -87.6129 ymax: 41.88893 ## geographic CRS: WGS 84 ## GEOID10 ZCTA5CE10 CLASSFP10 MTFCC10 FUNCSTAT10 ALAND10 AWATER10 INTPTLAT10 INTPTLON10 ZIP.Code Week.Number Week.Start ## 1 60601 60601 B5 G6350 S 934226 60682 +41.8856419 -087.6215226 60601 39 09/20/2020 ## 2 60601 60601 B5 G6350 S 934226 60682 +41.8856419 -087.6215226 60601 33 08/09/2020 ## 3 60601 60601 B5 G6350 S 934226 60682 +41.8856419 -087.6215226 60601 34 08/16/2020 ## 4 60601 60601 B5 G6350 S 934226 60682 +41.8856419 -087.6215226 60601 25 06/14/2020 ## 5 60601 60601 B5 G6350 S 934226 60682 +41.8856419 -087.6215226 60601 13 03/22/2020 ## 6 60601 60601 B5 G6350 S 934226 60682 +41.8856419 -087.6215226 60601 22 05/24/2020 ## Week.End Cases...Weekly Cases...Cumulative Case.Rate...Weekly Case.Rate...Cumulative Tests...Weekly Tests...Cumulative ## 1 09/26/2020 8 213 54 1451.4 202 4304 ## 2 08/15/2020 8 128 54 872.2 216 2303 ## 3 08/22/2020 7 135 48 919.9 240 2543 ## 4 06/20/2020 5 82 34 558.8 100 881 ## 5 03/28/2020 9 23 61 156.7 39 79 ## 6 05/30/2020 2 70 14 477.0 92 617 ## Test.Rate...Weekly Test.Rate...Cumulative Percent.Tested.Positive...Weekly Percent.Tested.Positive...Cumulative ## 1 1376 29328.8 0.0 0.0 ## 2 1472 15693.4 0.0 0.1 ## 3 1635 17328.8 0.0 0.1 ## 4 681 6003.4 0.0 0.1 ## 5 266 538.3 0.2 0.3 ## 6 627 4204.4 0.0 0.1 ## Deaths...Weekly Deaths...Cumulative Death.Rate...Weekly Death.Rate...Cumulative Population Row.ID ## 1 1 6 6.8 40.9 14675 60601-39 ## 2 0 5 0.0 34.1 14675 60601-33 ## 3 0 5 0.0 34.1 14675 60601-34 ## 4 0 5 0.0 34.1 14675 60601-25 ## 5 0 0 0.0 0.0 14675 60601-13 ## 6 0 4 0.0 27.3 14675 60601-22 ## ZIP.Code.Location geometry ## 1 POINT (-87.622844 41.886262) MULTIPOLYGON (((-87.63396 4... ## 2 POINT (-87.622844 41.886262) MULTIPOLYGON (((-87.63396 4... ## 3 POINT (-87.622844 41.886262) MULTIPOLYGON (((-87.63396 4... ## 4 POINT (-87.622844 41.886262) MULTIPOLYGON (((-87.63396 4... ## 5 POINT (-87.622844 41.886262) MULTIPOLYGON (((-87.63396 4... ## 6 POINT (-87.622844 41.886262) MULTIPOLYGON (((-87.63396 4... new$COVIDCaseRt &lt;- new$Case.Rate...Cumulative str(new) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 1798 obs. of 32 variables: ## $ GEOID10 : chr &quot;60601&quot; &quot;60601&quot; &quot;60601&quot; &quot;60601&quot; ... ## $ ZCTA5CE10 : chr &quot;60601&quot; &quot;60601&quot; &quot;60601&quot; &quot;60601&quot; ... ## $ CLASSFP10 : chr &quot;B5&quot; &quot;B5&quot; &quot;B5&quot; &quot;B5&quot; ... ## $ MTFCC10 : chr &quot;G6350&quot; &quot;G6350&quot; &quot;G6350&quot; &quot;G6350&quot; ... ## $ FUNCSTAT10 : chr &quot;S&quot; &quot;S&quot; &quot;S&quot; &quot;S&quot; ... ## $ ALAND10 : chr &quot;934226&quot; &quot;934226&quot; &quot;934226&quot; &quot;934226&quot; ... ## $ AWATER10 : chr &quot;60682&quot; &quot;60682&quot; &quot;60682&quot; &quot;60682&quot; ... ## $ INTPTLAT10 : chr &quot;+41.8856419&quot; &quot;+41.8856419&quot; &quot;+41.8856419&quot; &quot;+41.8856419&quot; ... ## $ INTPTLON10 : chr &quot;-087.6215226&quot; &quot;-087.6215226&quot; &quot;-087.6215226&quot; &quot;-087.6215226&quot; ... ## $ ZIP.Code : chr &quot;60601&quot; &quot;60601&quot; &quot;60601&quot; &quot;60601&quot; ... ## $ Week.Number : int 39 33 34 25 13 22 27 35 24 11 ... ## $ Week.Start : chr &quot;09/20/2020&quot; &quot;08/09/2020&quot; &quot;08/16/2020&quot; &quot;06/14/2020&quot; ... ## $ Week.End : chr &quot;09/26/2020&quot; &quot;08/15/2020&quot; &quot;08/22/2020&quot; &quot;06/20/2020&quot; ... ## $ Cases...Weekly : int 8 8 7 5 9 2 3 13 6 NA ... ## $ Cases...Cumulative : int 213 128 135 82 23 70 89 148 77 NA ... ## $ Case.Rate...Weekly : int 54 54 48 34 61 14 20 89 41 NA ... ## $ Case.Rate...Cumulative : num 1451 872 920 559 157 ... ## $ Tests...Weekly : int 202 216 240 100 39 92 132 254 93 6 ... ## $ Tests...Cumulative : int 4304 2303 2543 881 79 617 1161 2797 781 7 ... ## $ Test.Rate...Weekly : int 1376 1472 1635 681 266 627 900 1731 634 41 ... ## $ Test.Rate...Cumulative : num 29329 15693 17329 6003 538 ... ## $ Percent.Tested.Positive...Weekly : num 0 0 0 0 0.2 0 0 0.1 0.1 NA ... ## $ Percent.Tested.Positive...Cumulative: num 0 0.1 0.1 0.1 0.3 0.1 0.1 0.1 0.1 NA ... ## $ Deaths...Weekly : int 1 0 0 0 0 0 0 0 0 0 ... ## $ Deaths...Cumulative : int 6 5 5 5 0 4 5 5 5 0 ... ## $ Death.Rate...Weekly : num 6.8 0 0 0 0 0 0 0 0 0 ... ## $ Death.Rate...Cumulative : num 40.9 34.1 34.1 34.1 0 27.3 34.1 34.1 34.1 0 ... ## $ Population : int 14675 14675 14675 14675 14675 14675 14675 14675 14675 14675 ... ## $ Row.ID : chr &quot;60601-39&quot; &quot;60601-33&quot; &quot;60601-34&quot; &quot;60601-25&quot; ... ## $ ZIP.Code.Location : chr &quot;POINT (-87.622844 41.886262)&quot; &quot;POINT (-87.622844 41.886262)&quot; &quot;POINT (-87.622844 41.886262)&quot; &quot;POINT (-87.622844 41.886262)&quot; ... ## $ geometry :sfc_MULTIPOLYGON of length 1798; first list element: List of 1 ## ..$ :List of 1 ## .. ..$ : num [1:183, 1:2] -87.6 -87.6 -87.6 -87.6 -87.6 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## $ COVIDCaseRt : num 1451 872 920 559 157 ... ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;names&quot;)= chr [1:31] &quot;GEOID10&quot; &quot;ZCTA5CE10&quot; &quot;CLASSFP10&quot; &quot;MTFCC10&quot; ... union.buffers&lt;- st_read(&quot;data/mclinicarea.shp&quot;) ## Reading layer `mclinicarea&#39; from data source `/Users/qinyun/Documents/opioid-environment-toolkit/data/mclinicarea.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 1 feature and 1 field ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 1136699 ymin: 1818770 xmax: 1201240 ymax: 1941031 ## projected CRS: NAD83 / Illinois East (ftUS) 3.5 Visualize Data tm_shape(new) + tm_polygons(&quot;COVIDCaseRt&quot;, style=&quot;jenks&quot;, pal=&quot;BuPu&quot;, title = &quot;COVID Case Rate&quot;) + tm_shape(union.buffers) + tm_borders(col = &quot;blue&quot;) + tm_shape(meth_sf) + tm_dots(col = &quot;black&quot;, size = 0.2) "],
["visualizeArealData-tutorial.html", "4 Thematic Mapping 4.1 Overview 4.2 Environment Setup 4.3 Load data 4.4 Thematic Plotting 4.5 Appendix", " 4 Thematic Mapping 4.1 Overview Once we have downloaded the contextual data and generated the access metrics, we can start visualizing them to identify any spatial patterns. This can help identify whether a variable is homogeneously distributed across space or do we see clustering &amp; spatial heterogeneity. In this tutorial we will cover methods to plot data variables spatially i.e. create thematic maps, technically known as choropleth maps. We will cover the most commonly used types of choropleth mapping techniques employed in R. Please note the methods covered here are mere an introduction to spatial plotting. Thus, in this tutorial our objectives are to: item 1 item 2 item 3 4.2 Environment Setup To replicate the codes &amp; functions illustrated in this tutorial, you’ll need to have R and RStudio downloaded and installed on your system. This tutorial assumes some familiarity with the R programming language. 4.2.0.1 Packages used We will use the following packages in this tutorial: tidyverse: to manipulate data tmap: to visualize and create maps sf: to read/write and manipulate spatial data 4.2.0.2 Required Inputs and Expected Outputs We will using the race data for Illinois downloaded &amp; saved as a shapefile using the get-ACS_Data tutorial from the Census Bureau. Our output will be three thematic maps highlighting the distribution of percentage hispanic population at a county level across the state of Illinois. 4.2.0.3 Load libraries First, load the libraries required. library(tidyverse) library(tmap) library(sf) 4.3 Load data We will read in the shapefile with percentage hispanic population at the county level for the state of Illinois for year 2018.Alternatively, if you have not saved the dataset from get-ACS-Data tutorial, you can access it here. ILcounties &lt;- st_read(&quot;data/IL_County_18.shp&quot;) ## Reading layer `IL_County_18&#39; from data source `/Users/qinyun/Documents/opioid-environment-toolkit/data/IL_County_18.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 102 features and 8 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -91.51308 ymin: 36.9703 xmax: -87.4952 ymax: 42.50848 ## geographic CRS: NAD83 head(ILcounties) ## Simple feature collection with 6 features and 8 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -91.51308 ymin: 36.9703 xmax: -88.70541 ymax: 42.49505 ## geographic CRS: NAD83 ## GEOID STATEFP COUNTYFP totPop18 hispPr18 WhitePr18 AfrAmPr18 AsianPr18 geometry ## 1 17001 17 001 66427 0.01537026 0.9306306 0.040826772 0.0081292246 POLYGON ((-91.51297 40.1810... ## 2 17003 17 003 6532 0.01117575 0.6243111 0.332057563 0.0009185548 POLYGON ((-89.51839 37.2893... ## 3 17005 17 005 16712 0.03458593 0.9088679 0.062410244 0.0117280996 POLYGON ((-89.63926 38.9991... ## 4 17007 17 007 53606 0.21376338 0.8741745 0.022199008 0.0118083797 POLYGON ((-88.94098 42.2388... ## 5 17009 17 009 6675 0.04284644 0.7742322 0.204344569 0.0055430712 POLYGON ((-90.91703 39.9022... ## 6 17011 17 011 33381 0.08972170 0.9361613 0.009316677 0.0086576196 POLYGON ((-89.86235 41.584,... Lets review the dataset structure. In the R sf data object, the ‘geometry’ column provides the geographic information/boundaries that we can map. This is unique to simple features data structures, and a pretty phenomenal concept. We can do a quick plot using: plot(ILcounties$geometry) Before we move ahead, lets convert the percentages for easy plotting using some tidyverse thinking. View the dataframe afterwards to confirm your change was successful. **Moksha note – please explain what is happening here, how this uses the tidyvrse, etc – ILcounties &lt;- ILcounties %&gt;% mutate_at(vars(hispPr18:AsianPr18), .funs = funs(round(. * 100,2))) head(ILcounties) ## Simple feature collection with 6 features and 8 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -91.51308 ymin: 36.9703 xmax: -88.70541 ymax: 42.49505 ## geographic CRS: NAD83 ## GEOID STATEFP COUNTYFP totPop18 hispPr18 WhitePr18 AfrAmPr18 AsianPr18 geometry ## 1 17001 17 001 66427 1.54 93.06 4.08 0.81 POLYGON ((-91.51297 40.1810... ## 2 17003 17 003 6532 1.12 62.43 33.21 0.09 POLYGON ((-89.51839 37.2893... ## 3 17005 17 005 16712 3.46 90.89 6.24 1.17 POLYGON ((-89.63926 38.9991... ## 4 17007 17 007 53606 21.38 87.42 2.22 1.18 POLYGON ((-88.94098 42.2388... ## 5 17009 17 009 6675 4.28 77.42 20.43 0.55 POLYGON ((-90.91703 39.9022... ## 6 17011 17 011 33381 8.97 93.62 0.93 0.87 POLYGON ((-89.86235 41.584,... 4.4 Thematic Plotting We will be using tmap package for plotting spatial data distributions. The package syntax has similarities with ggplot2 and follows the same idea of A Layered Grammar of Graphics. for each input data layer use tm_shape(), followed by the method to plot it, e.g tm_fill() or tm_dots() or tm_line() or tm_borders() etc. Similar to ggplot2, aesthetics can be provided for each layer and plot layout can be manipulated using tm_layout(). For more details on tmap usage &amp; functionality, check tmap documentation. The previous map we plotted using plot can be mapped using tmap as in the code below. tmap_mode(&#39;plot&#39;) ## tmap mode set to plotting tm_shape(ILcounties) + tm_borders() + tm_layout(frame = FALSE) In tmap, the classification scheme is set by the style option in tm_fill() and the default style is pretty. Lets plot the distribution of percentage of hispanic population by county across the state of Illinois with default style using the code below. We can also change the color palette used to depict the spatial distribution. See Set Color Palette in Appendix for more details on that. tm_shape(ILcounties) + tm_fill(&#39;hispPr18&#39;, title = &#39;PctHispanic% - Pretty&#39;) + tm_borders() + tm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, legend.title.size = 0.9, main.title = &#39;Pct of hispanic population by county, IL 2018&#39;, main.title.size = 0.9) We will be plotting the spatial distribution of variable hispPr18 for the state of Illinois using three methods. Quantile Natural Breaks Standard Deviation For detailed documentation on choropleth mapping and methods use check GeoDa Center Documentation. 4.4.1 Quantile A quantile map is based on sorted values for the variable that are then grouped into bins such that each bin has the same number of observations. It is obtained by setting style = 'quantile' and n = no of bins arguments in tm_fill(). p1 &lt;- tm_shape(ILcounties) + tm_fill(&#39;hispPr18&#39;, title = &#39;PctHispanic% - Quantile&#39;, style = &#39;quantile&#39;, n = 5) + tm_borders() + tm_layout(frame = FALSE,legend.outside = TRUE, legend.outside.position = &#39;right&#39;, legend.title.size =0.9, main.title = &#39;Pct of hispanic population by county, IL 2018&#39;, main.title.size = 0.9) #tmap_save(p1, &#39;PctHisp_18_Quantile.png&#39;) # save the map in a .png file p1 4.4.2 Natural Breaks Natural breaks or jenks distribution uses a nonlinear algorithm to cluster data into groups such that the intra-bin similarity is maximized and inter-bin dissimilarity is minimized. It is obtained by setting style = 'jenks' and n = no. of bins in the tm_fill(). As we can see, jenks method better classifies the dataset in review than the quantile distribution. There is no correct method to use and the choice of classification method is dependent on the problem &amp; dataset used. p2 &lt;- tm_shape(ILcounties) + tm_fill(&#39;hispPr18&#39;, title = &#39;PctHispanic% - Jenks&#39;, style = &#39;jenks&#39;, n = 5) + tm_borders() + tm_layout(frame = FALSE,legend.outside = TRUE, legend.outside.position = &#39;right&#39;, legend.title.size =0.9, main.title = &#39;Pct of hispanic population by county, IL 2018&#39;, main.title.size = 0.9) #tmap_save(p2, &#39;PctHisp_18_Jenks.png&#39;)# save the map in a .png file p2 4.4.3 Standard Deviation A standard deviation map normalizes the dataset (mean = 0, stdev = 1) and transforms it into units of stdev (given mean =0). It helps identify outliers in the dataset. It is obtained by setting style = 'sd' in the tm_fill(). The normalization process can create bins with negative values, which in this case don’t necessarily make sense for the dataset, but it still helps identify the outliers. p3 &lt;- tm_shape(ILcounties) + tm_fill(&#39;hispPr18&#39;, title = &#39;PctHispanic% - Stdev&#39;, style = &#39;sd&#39;) + tm_borders() + tm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, legend.title.size =0.9, main.title = &#39;Pct of hispanic population by county, IL 2018&#39;, main.title.size = 0.9) #tmap_save(p3, &#39;PctHisp_18_Stdev.png&#39;)# save the map in a .png file p3 4.5 Appendix Set Color Palette The range of colors used to depict the distribution in the map can be set by modifying the palette argument in tm_fill(). For example, we can use Blues palette to create the map below. tm_shape(ILcounties) + tm_fill(&#39;hispPr18&#39;, title = &#39;PctHispanic% - Jenks&#39;, style = &#39;jenks&#39;, n = 5, palette = &#39;Blues&#39;) + tm_borders() + tm_layout(frame = FALSE,legend.outside = TRUE, legend.outside.position = &#39;right&#39;, legend.title.size =0.9, main.title = &#39;Pct of hispanic population by county, IL 2018&#39;, main.title.size = 0.9) Use ColorBrewer To build aesthetically pleasing and easy-to-read maps, we recommend using color palette schemes recommended in ColorBrewer 2.0 developed by Cynthia Brewer. The website distinguishes between sequential(ordered), diverging(spread around a center) &amp; qualitative(categorical) data. Information on these palettes cab be displayed in R using RColorBrewer package. We can get the hex values for the colors used in a specific palette with n bins &amp; plot the corresponding colors using code below. require(RColorBrewer) RColorBrewer::brewer.pal(5,&quot;PuBuGn&quot;) ## [1] &quot;#F6EFF7&quot; &quot;#BDC9E1&quot; &quot;#67A9CF&quot; &quot;#1C9099&quot; &quot;#016C59&quot; RColorBrewer::display.brewer.pal(5,&quot;PuBuGn&quot;) We can update the jenks map by using this sequential color scheme and changing the transparency using alpha = 0.8 as below. tm_shape(ILcounties) + tm_fill(&#39;hispPr18&#39;, title = &#39;PctHispanic% - Jenks&#39;, style = &#39;jenks&#39;, n = 5, palette = &#39;PuBuGn&#39;) + tm_borders() + tm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, legend.title.size =0.9, main.title = &#39;Pct of hispanic population by county, IL 2018&#39;, main.title.size = 0.9) We can also update the stdev map by using a diverging color scheme as below. tm_shape(ILcounties) + tm_fill(&#39;hispPr18&#39;, title = &#39;PctHispanic% - Stdev&#39;, style = &#39;sd&#39;, palette = &#39;-RdBu&#39;, alpha = 0.9) + tm_borders() + tm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, legend.title.size =0.9, main.title = &#39;Pct of hispanic population by county, IL 2018&#39;, main.title.size = 0.9) "],
["centroid-access-tutorial.html", "5 Min. Dist Access Analysis 5.1 Overview 5.2 Environment Setup 5.3 Load data 5.4 Calculate centroids 5.5 Standardize CRS Calculate min distance 5.6 Save Data", " 5 Min. Dist Access Analysis 5.1 Overview Spatial Access to specific resource is often considered a multidimensional concept where accessibility can be measured on affordability, availability, accommodation &amp; acceptability [include reference]. Distance to the nearest resource is a common metric used to capture the availability of a resource, and in this tutorial we demonstrate how to calculate a minimum distance value from a zip code centroid to a set of resources, such as locations of methadone clinics. Each zip code will be assigned a “minimum distance access metric” as a value that indicates access to resources from that zip code. Our objectives are thus to: Generate centroids from areal data Calculate minimum distance from resources to area centroids Overlay resources and new minimum distance metric 5.2 Environment Setup To replicate the codes &amp; functions illustrated in this tutorial, you’ll need to have R and RStudio downloaded and installed on your system. This tutorial assumes some familiarity with the R programming language. 5.2.1 Packages used We will use the following packages in this tutorial: sf: to manipulate spatial data tmap: to visualize and create maps units: to convert units within spatial data 5.2.2 Required Inputs and Expected Outputs Our inputs will be: a CSV file with the locations of our resources (“chicago_methadone.csv”), and a zip code boundary file (“chicago_zips.shp”). We will calculate the minimum distance between the resources and the centroids of the zip codes, then save the results as a shapefile and as a CSV. Our final result will be a shapefile/CSV with the minimum distance value for each zip. 5.2.3 Load the packages Load the libraries for use. library(sf) library(tmap) library(units) 5.3 Load data First, load in the MOUD resources shapefile. Let’s take a look at the first few rows of the dataset. meth_sf &lt;- st_read(&quot;methadoneClinics.shp&quot;) ## Reading layer `methadoneClinics&#39; from data source `/Users/qinyun/Documents/opioid-environment-toolkit/methadoneClinics.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 27 features and 8 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: -87.7349 ymin: 41.68698 xmax: -87.57673 ymax: 41.96475 ## geographic CRS: WGS 84 head(meth_sf) ## Simple feature collection with 6 features and 8 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: -87.67818 ymin: 41.89268 xmax: -87.63409 ymax: 41.96475 ## geographic CRS: WGS 84 ## X Name Address City State Zip ## 1 1 Chicago Treatment and Counseling Center, Inc. 4453 North Broadway st. Chicago IL 60640 ## 2 2 Sundace Methadone Treatment Center, LLC 4545 North Broadway St. Chicago IL 60640 ## 3 3 Soft Landing Interventions/DBA Symetria Recovery of Lakeview 3934 N. Lincoln Ave. Chicago IL 60613 ## 4 4 PDSSC - Chicago, Inc. 2260 N. Elston Ave. Chicago IL 60614 ## 5 5 Center for Addictive Problems, Inc. 609 N. Wells St. Chicago IL 60654 ## 6 6 Family Guidance Centers, Inc. 310 W. Chicago Ave. Chicago IL 60654 ## fullAdd geo_method geometry ## 1 4453 North Broadway st. Chicago IL 60640 osm POINT (-87.65566 41.96321) ## 2 4545 North Broadway St. Chicago IL 60640 osm POINT (-87.65694 41.96475) ## 3 3934 N. Lincoln Ave. Chicago IL 60613 census POINT (-87.67818 41.95331) ## 4 2260 N. Elston Ave. Chicago IL 60614 census POINT (-87.67407 41.92269) ## 5 609 N. Wells St. Chicago IL 60654 census POINT (-87.63409 41.89268) ## 6 310 W. Chicago Ave. Chicago IL 60654 census POINT (-87.63636 41.89657) If you don’t have a shapefile of your data, but already have geographic coordinates as two columns in your CSV file, you can still use this tutorial. A reminder of how to transform your CSV with coordinates into a spatial data frame in R can be found here. Next, we’ll load Chicago zip code boundaries. chicago_zips &lt;- read_sf(&quot;data/chicago_zips.shp&quot;) We can quickly plot our data for to confirm they loaded correctly, here using an interactive map: tm_shape(chicago_zips) + tm_borders() + tm_shape(meth_sf) + tm_dots(col = &quot;blue&quot;, size = 0.2) 5.4 Calculate centroids Now, we will calculate the centroids of the zip code boundaries. We will first need to project our data, which means change it from latitude and longitude to meaningful units, like ft or meters, so we can calculate distance properly. We’ll use the Illinois State Plane projection, with an EPSG code of 3435. Aside: To find the most appropriate projection for your data, do a Google Search for which projection works well - for state level data, each state has a State Plane projection with a specific code, known as the EPSG. I use epsg.io to check projections - here’s the New York State Plane page. Use the st_transform function to change the projection of the data. Notice how the values in geometry go from being relatively small (unprojected, lat/long) to very large (projected, in US feet). chicago_zips &lt;- st_transform(chicago_zips, 3435) chicago_zips ## Simple feature collection with 85 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 1058388 ymin: 1791133 xmax: 1205317 ymax: 1966816 ## projected CRS: NAD83 / Illinois East (ftUS) ## # A tibble: 85 x 10 ## ZCTA5CE10 GEOID10 CLASSFP10 MTFCC10 FUNCSTAT10 ALAND10 AWATER10 INTPTLAT10 INTPTLON10 geometry ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [US_survey_foot]&gt; ## 1 60501 60501 B5 G6350 S 12532295 974360 +41.78022… -087.8232… (((1112613 1853447, 1112726 1853654,… ## 2 60007 60007 B5 G6350 S 36493383 917560 +42.00860… -087.9973… (((1058389 1942598, 1058390 1942800,… ## 3 60651 60651 B5 G6350 S 9052862 0 +41.90209… -087.7408… (((1136069 1909833, 1136235 1909836,… ## 4 60652 60652 B5 G6350 S 12987857 0 +41.74793… -087.7147… (((1145542 1859745, 1145607 1859746,… ## 5 60653 60653 B5 G6350 S 6041418 1696670 +41.81996… -087.6059… (((1177007 1875855, 1177096 1875857,… ## 6 60654 60654 B5 G6350 S 1464813 113471 +41.89182… -087.6383… (((1170904 1905583, 1170932 1905582,… ## 7 60655 60655 B5 G6350 S 11408010 0 +41.69477… -087.7037… (((1146378 1830511, 1146444 1830519,… ## 8 60656 60656 B5 G6350 S 8465226 0 +41.97428… -087.8271… (((1110359 1933204, 1110389 1933364,… ## 9 60657 60657 B5 G6350 S 5888324 2025836 +41.94029… -087.6468… (((1162394 1923242, 1162526 1923244,… ## 10 60659 60659 B5 G6350 S 5251086 2818 +41.99148… -087.7039… (((1148555 1941516, 1148713 1941519,… ## # … with 75 more rows Then, we will calculate the centroids: chicago_centroids &lt;- st_centroid(chicago_zips) ## Warning in st_centroid.sf(chicago_zips): st_centroid assumes attributes are constant over geometries of x chicago_centroids ## Simple feature collection with 85 features and 9 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 1076716 ymin: 1802621 xmax: 1198093 ymax: 1956017 ## projected CRS: NAD83 / Illinois East (ftUS) ## # A tibble: 85 x 10 ## ZCTA5CE10 GEOID10 CLASSFP10 MTFCC10 FUNCSTAT10 ALAND10 AWATER10 INTPTLAT10 INTPTLON10 geometry ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;POINT [US_survey_foot]&gt; ## 1 60501 60501 B5 G6350 S 12532295 974360 +41.7802209 -087.8232440 (1123181 1862885) ## 2 60007 60007 B5 G6350 S 36493383 917560 +42.0086000 -087.9973398 (1076716 1945541) ## 3 60651 60651 B5 G6350 S 9052862 0 +41.9020934 -087.7408565 (1145540 1907470) ## 4 60652 60652 B5 G6350 S 12987857 0 +41.7479319 -087.7147951 (1153039 1851344) ## 5 60653 60653 B5 G6350 S 6041418 1696670 +41.8199645 -087.6059654 (1182494 1877789) ## 6 60654 60654 B5 G6350 S 1464813 113471 +41.8918225 -087.6383036 (1173771 1904104) ## 7 60655 60655 B5 G6350 S 11408010 0 +41.6947762 -087.7037764 (1156187 1831997) ## 8 60656 60656 B5 G6350 S 8465226 0 +41.9742800 -087.8271283 (1121899 1933624) ## 9 60657 60657 B5 G6350 S 5888324 2025836 +41.9402931 -087.6468569 (1170365 1921589) ## 10 60659 60659 B5 G6350 S 5251086 2818 +41.9914885 -087.7039859 (1155320 1939992) ## # … with 75 more rows For each zip code, this will calculate the centroid, and the output will be a point dataset. Plot to double check that everything is ok. The st_geometry() function will once again just return the outline: plot(st_geometry(chicago_zips)) plot(st_geometry(chicago_centroids), add = TRUE, col = &quot;red&quot;) 5.4.1 Visualize &amp; Confirm Once again, we can create an interactive map: tm_shape(chicago_zips) + tm_borders() + tm_shape(chicago_centroids) + tm_dots() 5.5 Standardize CRS If we immediately try to calculate the distance between the zip centroids and the locations of the resources using the st_distance function, we’ll get an error: st_distance(chicago_centroids, meth_sf, by_element = TRUE) Error in st_distance(chicago_centroids, meth_sf, by_element = TRUE) : st_crs(x) == st_crs(y) is not TRUE Why is there an error? Because the projection of the centroids and the resource locations don’t match up. Let’s project the resource locations so that they match the projection of the centroids. First, use the st_crs function to check that the coordinate reference system (or projection) is the same. They’re not, so we have to fix it. st_crs(chicago_centroids) ## Coordinate Reference System: ## User input: EPSG:3435 ## wkt: ## PROJCRS[&quot;NAD83 / Illinois East (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Illinois East zone (US Survey feet)&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,36.6666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-88.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.999975, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,984250, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;USA - Illinois - SPCS - E&quot;], ## BBOX[37.06,-89.28,42.5,-87.02]], ## ID[&quot;EPSG&quot;,3435]] st_crs(meth_sf) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] We’ll take the CRS from the zip code centroids data, and use it as input to st_transform applied to the methadone clinics data. new_crs &lt;- st_crs(chicago_centroids) new_crs ## Coordinate Reference System: ## User input: EPSG:3435 ## wkt: ## PROJCRS[&quot;NAD83 / Illinois East (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Illinois East zone (US Survey feet)&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,36.6666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-88.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.999975, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,984250, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;USA - Illinois - SPCS - E&quot;], ## BBOX[37.06,-89.28,42.5,-87.02]], ## ID[&quot;EPSG&quot;,3435]] meth_sf &lt;- st_transform(meth_sf, new_crs) If we check the CRS again, we now see that they match. Mismatched projections are a commonly made mistake in geospatial data processing. st_crs(chicago_centroids) ## Coordinate Reference System: ## User input: EPSG:3435 ## wkt: ## PROJCRS[&quot;NAD83 / Illinois East (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Illinois East zone (US Survey feet)&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,36.6666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-88.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.999975, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,984250, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;USA - Illinois - SPCS - E&quot;], ## BBOX[37.06,-89.28,42.5,-87.02]], ## ID[&quot;EPSG&quot;,3435]] st_crs(meth_sf) ## Coordinate Reference System: ## User input: EPSG:3435 ## wkt: ## PROJCRS[&quot;NAD83 / Illinois East (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Illinois East zone (US Survey feet)&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,36.6666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-88.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.999975, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,984250, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;USA - Illinois - SPCS - E&quot;], ## BBOX[37.06,-89.28,42.5,-87.02]], ## ID[&quot;EPSG&quot;,3435]] Now we have the zip boundaries, the centroids of the zips, and the resource locations, as shown below. Next, we will calculate the distance to the nearest resource from each zip code centroid. plot(st_geometry(chicago_zips)) plot(st_geometry(chicago_centroids), col = &quot;red&quot;, add = TRUE) plot(st_geometry(meth_sf), col = &quot;blue&quot;, add = TRUE) Calculate min distance First, we’ll identify the resource that is the closest to a zip centroid using the st_nearest_feature function. (It will return the index of the object that is nearest, so we will subset the resources by the index to get the nearest object.) nearest_clinic_indexes &lt;- st_nearest_feature(chicago_centroids, meth_sf) nearest_clinic &lt;- meth_sf[nearest_clinic_indexes,] nearest_clinic ## Simple feature collection with 85 features and 8 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 1147259 ymin: 1829330 xmax: 1190680 ymax: 1930471 ## projected CRS: NAD83 / Illinois East (ftUS) ## First 10 features: ## X Name Address City State Zip ## 16 16 Katherine Boone Robinson Foundation 4100 W. Ogden Ave. Chicago IL 60623 ## 7 7 A Rincon Family Services 3809 W. Grand Ave. Chicago IL 60651 ## 7.1 7 A Rincon Family Services 3809 W. Grand Ave. Chicago IL 60651 ## 26 26 New Hope Community Service Center 2559 W. 79th St. Chicago IL 60652 ## 15 15 HRDI- Grand Boulevard Professional Counseling Center 340 E. 51st St. Chicago IL 60615 ## 5 5 Center for Addictive Problems, Inc. 609 N. Wells St. Chicago IL 60654 ## 26.1 26 New Hope Community Service Center 2559 W. 79th St. Chicago IL 60652 ## 7.2 7 A Rincon Family Services 3809 W. Grand Ave. Chicago IL 60651 ## 1 1 Chicago Treatment and Counseling Center, Inc. 4453 North Broadway st. Chicago IL 60640 ## 3 3 Soft Landing Interventions/DBA Symetria Recovery of Lakeview 3934 N. Lincoln Ave. Chicago IL 60613 ## fullAdd geo_method geometry ## 16 4100 W. Ogden Ave. Chicago IL 60623 census POINT (1149437 1888620) ## 7 3809 W. Grand Ave. Chicago IL 60651 census POINT (1150707 1908328) ## 7.1 3809 W. Grand Ave. Chicago IL 60651 census POINT (1150707 1908328) ## 26 2559 W. 79th St. Chicago IL 60652 osm POINT (1160422 1852071) ## 15 340 E. 51st St. Chicago IL 60615 census POINT (1179319 1871281) ## 5 609 N. Wells St. Chicago IL 60654 census POINT (1174632 1904257) ## 26.1 2559 W. 79th St. Chicago IL 60652 osm POINT (1160422 1852071) ## 7.2 3809 W. Grand Ave. Chicago IL 60651 census POINT (1150707 1908328) ## 1 4453 North Broadway st. Chicago IL 60640 osm POINT (1168556 1929911) ## 3 3934 N. Lincoln Ave. Chicago IL 60613 census POINT (1162460 1926257) Then, we will calculate the distance between the nearest resource and the zip code centroid with the st_distance function. As shown above, make sure both of your datasets are projected, and in the same projection, before you run st_distance. min_dists &lt;- st_distance(chicago_centroids, nearest_clinic, by_element = TRUE) min_dists ## Units: [US_survey_foot] ## [1] 36764.471 82821.757 5237.764 7419.050 7241.215 873.991 20515.835 38337.779 8516.342 15479.988 9823.172 4447.705 ## [13] 33707.202 24111.173 24184.991 45224.230 31198.648 10113.372 10890.143 13779.075 49874.400 32463.844 36633.404 21981.243 ## [25] 13637.327 22151.171 63268.911 4242.008 3749.998 5116.415 5530.724 8696.602 3965.649 4368.285 6998.725 6937.025 ## [37] 3967.509 45944.187 32598.459 44548.952 58483.551 5416.487 5728.851 2327.899 6646.411 5817.262 365.628 13619.270 ## [49] 7021.182 5024.536 2829.488 1648.361 7709.690 2628.400 1521.495 9423.848 16648.775 2185.237 11463.785 22537.644 ## [61] 11872.133 7759.662 39665.409 11741.279 18689.070 27555.396 5301.820 8808.542 25363.914 18986.590 26456.564 7562.917 ## [73] 3496.941 11023.379 3128.000 16826.923 6172.874 25276.556 17290.797 15198.524 25164.072 18438.696 19972.965 33211.229 ## [85] 22518.257 This is in US feet. To change to a more meaningful unit, such as miles, we can use the set_units() function: min_dists_mi &lt;- set_units(min_dists, &quot;mi&quot;) min_dists_mi ## Units: [mi] ## [1] 6.96298198 15.68597011 0.99200275 1.40512596 1.37144503 0.16552893 3.88558262 7.26095754 1.61294677 2.93182182 ## [11] 1.86045293 0.84236999 6.38395252 4.56651915 4.58049994 8.56521226 5.90884663 1.91541520 2.06253115 2.60967860 ## [21] 9.44592795 6.14846754 6.93815858 4.16312245 2.58283224 4.19530595 11.98277234 0.80341215 0.71022833 0.96901998 ## [31] 1.04748778 1.64708702 0.75107138 0.82732834 1.32551867 1.31383303 0.75142366 8.70156788 6.17396283 8.43731838 ## [41] 11.07645233 1.02585189 1.08501190 0.44089088 1.25879245 1.10175645 0.06924787 2.57941243 1.32977202 0.95161851 ## [51] 0.53588899 0.31219014 1.46017146 0.49780409 0.28816254 1.78482335 3.15318335 0.41387148 2.17117583 4.26850167 ## [61] 2.24851459 1.46963585 7.51240307 2.22373150 3.53960367 5.21883539 1.00413457 1.66828778 4.80378114 3.59595236 ## [71] 5.01072284 1.43237347 0.66230081 2.08776534 0.59242542 3.18692368 1.16910723 4.78723618 3.27477863 2.87851400 ## [81] 4.76593224 3.49218425 3.78276617 6.29001804 4.26482998 5.5.1 Merge data back to Area Data We then rejoin the minimum distances to the zip code data, by column binding min_dists_mi to the original chicago_zips data. min_dist_sf &lt;- cbind(chicago_zips, min_dists_mi) min_dist_sf ## Simple feature collection with 85 features and 10 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 1058388 ymin: 1791133 xmax: 1205317 ymax: 1966816 ## projected CRS: NAD83 / Illinois East (ftUS) ## First 10 features: ## ZCTA5CE10 GEOID10 CLASSFP10 MTFCC10 FUNCSTAT10 ALAND10 AWATER10 INTPTLAT10 INTPTLON10 min_dists_mi ## 1 60501 60501 B5 G6350 S 12532295 974360 +41.7802209 -087.8232440 6.9629820 [mi] ## 2 60007 60007 B5 G6350 S 36493383 917560 +42.0086000 -087.9973398 15.6859701 [mi] ## 3 60651 60651 B5 G6350 S 9052862 0 +41.9020934 -087.7408565 0.9920027 [mi] ## 4 60652 60652 B5 G6350 S 12987857 0 +41.7479319 -087.7147951 1.4051260 [mi] ## 5 60653 60653 B5 G6350 S 6041418 1696670 +41.8199645 -087.6059654 1.3714450 [mi] ## 6 60654 60654 B5 G6350 S 1464813 113471 +41.8918225 -087.6383036 0.1655289 [mi] ## 7 60655 60655 B5 G6350 S 11408010 0 +41.6947762 -087.7037764 3.8855826 [mi] ## 8 60656 60656 B5 G6350 S 8465226 0 +41.9742800 -087.8271283 7.2609575 [mi] ## 9 60657 60657 B5 G6350 S 5888324 2025836 +41.9402931 -087.6468569 1.6129468 [mi] ## 10 60659 60659 B5 G6350 S 5251086 2818 +41.9914885 -087.7039859 2.9318218 [mi] ## geometry ## 1 MULTIPOLYGON (((1112613 185... ## 2 MULTIPOLYGON (((1058389 194... ## 3 MULTIPOLYGON (((1136069 190... ## 4 MULTIPOLYGON (((1145542 185... ## 5 MULTIPOLYGON (((1177007 187... ## 6 MULTIPOLYGON (((1170904 190... ## 7 MULTIPOLYGON (((1146378 183... ## 8 MULTIPOLYGON (((1110359 193... ## 9 MULTIPOLYGON (((1162394 192... ## 10 MULTIPOLYGON (((1148555 194... 5.5.2 Visualize &amp; Confirm We can now visualize the zip-level access to methadone clinics using our new access metric, using the tmap package. tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting tm_shape(min_dist_sf) + tm_polygons(&quot;min_dists_mi&quot;, title = &quot;Minimum Distance (mi)&quot;) + tm_layout(main.title = &quot;Minimum Distance from Zip Centroid\\n to Methadone Clinic&quot;, main.title.position = &quot;center&quot;, main.title.size = 1) Access by zip code can also be combined with locations of resources: tm_shape(min_dist_sf) + tm_polygons(&quot;min_dists_mi&quot;, style = &#39;jenks&#39;, title = &quot;Minimum Distance (mi)&quot;) + tm_shape(meth_sf) + tm_dots(size = 0.2) + tm_layout(main.title = &quot;Minimum Distance from Zip Centroid\\n to Methadone Clinic&quot;, main.title.position = &quot;center&quot;, main.title.size = 1) head(chicago_zips) ## Simple feature collection with 6 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 1058388 ymin: 1846408 xmax: 1189038 ymax: 1957548 ## projected CRS: NAD83 / Illinois East (ftUS) ## # A tibble: 6 x 10 ## ZCTA5CE10 GEOID10 CLASSFP10 MTFCC10 FUNCSTAT10 ALAND10 AWATER10 INTPTLAT10 INTPTLON10 geometry ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [US_survey_foot]&gt; ## 1 60501 60501 B5 G6350 S 12532295 974360 +41.78022… -087.8232… (((1112613 1853447, 1112726 1853654, … ## 2 60007 60007 B5 G6350 S 36493383 917560 +42.00860… -087.9973… (((1058389 1942598, 1058390 1942800, … ## 3 60651 60651 B5 G6350 S 9052862 0 +41.90209… -087.7408… (((1136069 1909833, 1136235 1909836, … ## 4 60652 60652 B5 G6350 S 12987857 0 +41.74793… -087.7147… (((1145542 1859745, 1145607 1859746, … ## 5 60653 60653 B5 G6350 S 6041418 1696670 +41.81996… -087.6059… (((1177007 1875855, 1177096 1875857, … ## 6 60654 60654 B5 G6350 S 1464813 113471 +41.89182… -087.6383… (((1170904 1905583, 1170932 1905582, … 5.6 Save Data To save our final result to a CSV: write_sf(min_dist_sf, &quot;chizips_Access.csv&quot;) We can also write out this data to a shapefile format: write_sf(min_dist_sf, &quot;chizips_Access.shp&quot;) "]
]
